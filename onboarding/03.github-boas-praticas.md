---
title: Guia de Boas Práticas — Git/GitHub
parent: Playbook
nav_order: 1
---

# Guia de Boas Práticas para Organização de Repositórios GitHub

## 1. Introdução
Este guia explica as melhores práticas para organizar **branches** e **fluxo de trabalho** em repositórios GitHub, garantindo que o desenvolvimento seja **eficiente, seguro e colaborativo**.  
Seguindo estas diretrizes você mantém o código limpo, minimiza conflitos e facilita o deploy.

---

## 2. Estrutura de Branches
Uma boa estrutura de branches permite que o time trabalhe de forma organizada e que o código esteja sempre em um estado controlado.

### 2.1 Branch Principal (`main`)
- **Objetivo:** conter o código em **produção**.
- **Regra:** **nunca** fazer commits diretamente nesta branch.
- **Deploy:** conteúdo sempre pronto para ser implantado em produção.
- **Proteção recomendada:**
  - Configurar **branch protegida** no GitHub.
  - **Exigir revisão** de código antes do merge (no mínimo 1 revisor).
  - **Exigir checks do CI** (testes, lint, SCA) passando antes do merge.
  - **Impedir force-push** e **exigir branches atualizadas** antes do merge.

### 2.2 Branch de Homologação (`homolog`)
- **Objetivo:** simular o ambiente de produção para **testes finais**.
- **Regra:** receber merges a partir da `dev`.
- **Deploy:** validar novas funcionalidades e correções antes de ir para `main`.
- **Boas práticas:**
  - **Sempre** testar em `homolog` antes de promover para `main`.
  - Garantir validação por **QA** e/ou **stakeholders** aqui.

### 2.3 Branch de Desenvolvimento (`dev`)
- **Objetivo:** ambiente integrado para desenvolvimento.
- **Regra:** receber código via **Pull Requests** de branches `feature/*` ou `bugfix/*`.
- **Deploy:** opcional, para ambientes internos ou testes automatizados.
- **Boas práticas:**
  - Não commitar diretamente na `dev`.
  - Criar PRs e **solicitar revisão** de outro dev.
  - Manter `dev` **verde** (builds e testes sempre passando).

### 2.4 Branches de Funcionalidade (`feature/*`)
- **Objetivo:** desenvolver uma **nova funcionalidade** sem interferir no código principal.
- **Regra de nomenclatura:** `feature/nome-descritivo`  
  **Exemplos:** `feature/cadastro-usuario`, `feature/export-relatorios`
- **Dicas:**
  - Nomes curtos, claros e consistentes (pt ou en).

### 2.5 Branches de Correção (`bugfix/*`)
- **Objetivo:** corrigir **bugs** encontrados durante testes ou produção.
- **Regra de nomenclatura:** `bugfix/descricao-breve`  
  **Exemplos:** `bugfix/corrigir-login`, `bugfix/ajusta-paginacao`
- **Observação:** bugs críticos podem ser corrigidos a partir de `main` ou `homolog` (hotfix), seguindo o fluxo de release.

---

## 3. Fluxo de Trabalho (Git Flow simplificado)
### 3.1 Criação de branch
Sempre criar a branch a partir de `dev`:
```bash
git checkout dev
git pull origin dev
git checkout -b feature/nova-funcionalidade
```

### 3.2 Desenvolvimento
Faça commits **frequentes** e **bem descritos**:
```bash
git add .
git commit -m "feat: adiciona tela de cadastro de usuário"
```
Use **commits semânticos** (Conventional Commits):
- `feat:` → nova funcionalidade
- `fix:` → correção de bug
- `docs:` → documentação
- `refactor:` → refatoração que não altera comportamento
- `test:` → testes
- `chore:` → tarefas de suporte (build, deps, configs)

### 3.3 Manter a branch atualizada antes do PR
```bash
git checkout dev
git pull origin dev
git checkout feature/nova-funcionalidade
git merge dev    # ou rebase (ver política do time)
```
> Defina uma **política única**: `merge --no-ff` (histórico explícito) ou `rebase` (histórico linear). Em ambos os casos, evite conflitos grandes deixando o PR pequeno e sincronizando cedo.

### 3.4 Subir a branch para o repositório remoto
```bash
git push origin feature/nova-funcionalidade
```

### 3.5 Abrir Pull Request (PR)
No GitHub, crie um PR de `feature/nova-funcionalidade` → `dev`.  
Inclua na descrição:
- **Objetivo da mudança**
- **Como testar** (passos, dados de teste, flags/feature toggles)
- **Screenshots** (se aplicável)
- **Checklist** (ex.: testes passam, docs atualizadas)

### 3.6 Revisão e Merge
- Outro desenvolvedor revisa e aprova.
- Após aprovação e testes, **merge** na branch de destino.
- **Estratégia recomendada de merge:** **Squash & Merge** (um commit por PR) para histórico limpo.  
  Alternativas: **Merge commit** com `--no-ff` (preserva contexto) ou **Rebase & Merge** (linear). Escolha **uma** e padronize.

---

## 4. Ciclo de Integração
Fluxo de merges entre as branches:
```
feature/bugfix → dev → homolog → main
```
**Exemplo de fluxo completo:**
1. Dev cria `feature/cadastro-usuario` a partir de `dev`.
2. Implementa, commita e abre PR para `dev`.
3. Após revisão, faz merge em `dev` (build/QA automático).
4. Quando pronto para homologação, mergeia `dev` → `homolog`.
5. Após testes em `homolog`, mergeia `homolog` → `main` e libera em produção.

> Para **hotfixes críticos**, criar `hotfix/descricao` a partir de `main`, corrigir e abrir PR para `main`. Depois **propagar** a correção para `homolog` e `dev`.

---

## 5. Dicas Finais
- **Commits pequenos e claros:** facilitam revisão e bisect.
- **Nomes descritivos:** para branches e commits.
- **Revisão obrigatória:** nunca faça merge sem revisão.
- **Teste antes do PR:** rode testes localmente/CI.
- **Documente mudanças:** atualize README/CHANGELOG quando necessário.
- **PRs pequenos:** preferir vários PRs pequenos a um gigante.
- **Automatize checks:** lint, testes, SCA, formatação no CI.
- **Tags e Releases:** use SemVer (ex.: `v1.2.0`) e notas de release.
- **Proteja branches:** configure regras no GitHub (branch protection).

---

## 6. Políticas Recomendadas no GitHub (resumo prático)
- **Branch protection** em `main` e `homolog`:
  - Require pull request reviews: **ON**
  - Require status checks to pass: **ON** (CI: build, tests, lint, SCA)
  - Require branches to be up to date before merging: **ON**
  - Include administrators: **ON**
  - Restrict who can push to matching branches: **ON** para `main`
- **Merge strategy**: habilitar **Squash** e desabilitar **rebase** (ou vice-versa, conforme política).
- **Code Owners**: definir responsáveis por áreas do código via `CODEOWNERS`.
- **Templates**: usar `PULL_REQUEST_TEMPLATE.md` e `ISSUE_TEMPLATE`.

### Exemplos
**`CODEOWNERS`** (na raiz ou em `.github/`):
```
# Donos por diretório
/docs/       @time-docs
/src/api/    @time-backend
/src/web/    @time-frontend
*            @arquitetura
```

**`PULL_REQUEST_TEMPLATE.md`** (em `.github/`):
```md
## Objetivo
Descreva claramente o que este PR faz.

## Como testar
Passos para validação manual (e link do pipeline).

## Checklist
- [ ] Testes passam no CI
- [ ] Lint/format OK
- [ ] Documentação atualizada (se aplicável)
- [ ] Impacto em deploy/infra avaliado
```

---

## 7. Convenções de Mensagens de Commit (Conventional Commits)
**Formato:** `<tipo>(escopo opcional): descrição curta`  
**Tipos comuns:** `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `build`, `ci`  
**Exemplos:**
```
feat(auth): adiciona MFA no login
fix(api): corrige status code no endpoint de pedidos
docs(readme): atualiza instruções de setup
refactor: extrai serviço de email
test: adiciona testes de integração para checkout
```

---

## 8. Cheatsheet Rápido
| Ação | Comando |
|---|---|
| Atualizar `dev` | `git checkout dev && git pull origin dev` |
| Nova feature | `git checkout -b feature/minha-feature` |
| Nova correção | `git checkout -b bugfix/minha-correcao` |
| Adicionar mudanças | `git add .` |
| Commit semântico | `git commit -m "feat: descrição curta"` |
| Sincronizar com `dev` | `git checkout dev && git pull && git checkout feature/... && git merge dev` |
| Enviar branch | `git push origin feature/minha-feature` |
| Criar tag | `git tag -a v1.2.0 -m "release 1.2.0" && git push origin v1.2.0` |

---

## 9. Checklist de Qualidade para PRs
- [ ] Escopo claro e pequeno
- [ ] Descrição com **objetivo**, **como testar** e **screenshots** (se houver UI)
- [ ] Cobertura de testes adequada
- [ ] Lint/format passam localmente e no CI
- [ ] Risks/rollbacks considerados
- [ ] Aprovado por pelo menos **1 revisor** (ou conforme política)
